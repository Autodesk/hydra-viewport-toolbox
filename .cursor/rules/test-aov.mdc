---
description: How to create a unit test to display a specific AOV buffer
globs:
  - "test/**/*.cpp"
  - "test/**/*.h"
alwaysApply: true
---

# Creating a Unit Test to Display a Specific AOV Buffer

This rule explains how to create a unit test that validates the display of an AOV (Arbitrary Output Variable) buffer. Use this pattern when you need to test visualization of buffers like `primId`, `Neye`, `depth`, `color`, `elementId`, or `instanceId`.

**Important**: Before generating the test, always ask the user which file they want to add the unit test to.

**Important**: When generating the test code, include the user's original prompt as a comment at the beginning of the test function, right after the opening brace. Format it as:
```cpp
// Prompt: <user's original request>
```

## Reference Implementation: `display_primId_AOV`

The following test serves as the canonical example for AOV buffer display testing:

```cpp
HVT_TEST(TestViewportToolbox, display_primId_AOV)
{
    // Prompt: @aov-test primId

    // This unit test validates the display of the primId AOV buffer.

    auto context = TestHelpers::CreateTestContext();
    TestHelpers::TestStage stage(context->_backend);

    auto filepath = 
        (TestHelpers::getAssetsDataFolder() / "usd" / "default_scene.usdz").generic_u8string();
    ASSERT_TRUE(stage.open(filepath));

    // Define a frame pass.

    auto framePass = TestHelpers::FramePassInstance::CreateInstance(
        "HdStormRendererPlugin", stage.stage(), context->_backend);

    // Render 10 times (i.e., arbitrary number to guarantee best result).
    int frameCount = 10;

    auto render = [&]()
    {
        // Display the primId AOV buffer.
        auto& params        = framePass.sceneFramePass->params();
        params.visualizeAOV = pxr::HdAovTokens->primId;

        TestHelpers::RenderSecondFramePass(framePass, context->width(), context->height(),
            context->presentationEnabled(), stage, {}, true, TestHelpers::ColorDarkGrey, true);

        // Force GPU sync i.e., wait for all GPU commands to complete before proceeding.
        context->_backend->waitForGPUIdle();

        return --frameCount > 0;
    };

    // Run the render loop (i.e., that's backend specific).

    context->run(render, framePass.sceneFramePass.get());

    // Validate the rendering result.

    const std::string computedImagePath = TestHelpers::getComputedImagePath();
    ASSERT_TRUE(context->validateImages(computedImagePath, TestHelpers::gTestNames.fixtureName));
}
```

## Step-by-Step Guide

### 1. Test Declaration

Declare the test using the `HVT_TEST` macro with the test fixture and test name:

```cpp
HVT_TEST(TestViewportToolbox, display_<aov_name>_AOV)
```

### 2. Setup Test Context and Stage

```cpp
auto context = TestHelpers::CreateTestContext();
TestHelpers::TestStage stage(context->_backend);

auto filepath = 
    (TestHelpers::getAssetsDataFolder() / "usd" / "your_scene.usdz").generic_u8string();
ASSERT_TRUE(stage.open(filepath));
```

### 3. Create Frame Pass

```cpp
auto framePass = TestHelpers::FramePassInstance::CreateInstance(
    "HdStormRendererPlugin", stage.stage(), context->_backend);
```

### 4. Configure AOV Visualization in Render Lambda

Set the `params.visualizeAOV` to the desired AOV token:

```cpp
auto render = [&]()
{
    auto& params        = framePass.sceneFramePass->params();
    params.visualizeAOV = pxr::HdAovTokens-><aov_name>;  // e.g., primId, Neye, depth, color

    TestHelpers::RenderSecondFramePass(framePass, context->width(), context->height(),
        context->presentationEnabled(), stage, {}, true, TestHelpers::ColorDarkGrey, true);

    context->_backend->waitForGPUIdle();

    return --frameCount > 0;
};
```

### 5. Run Render Loop and Validate

```cpp
context->run(render, framePass.sceneFramePass.get());

const std::string computedImagePath = TestHelpers::getComputedImagePath();
ASSERT_TRUE(context->validateImages(computedImagePath, TestHelpers::gTestNames.fixtureName));
```

## Available AOV Tokens

Use `pxr::HdAovTokens->` with one of the following:

| Token       | Description                                      |
|-------------|--------------------------------------------------|
| `color`     | Final color buffer (default visualization)       |
| `depth`     | Depth buffer visualization                       |
| `primId`    | Primitive ID for selection/picking               |
| `elementId` | Element ID within a primitive                    |
| `instanceId`| Instance ID for instanced geometry               |
| `Neye`      | Eye-space normal buffer                          |

## Key Points

1. **GPU Synchronization**: Always call `context->_backend->waitForGPUIdle()` before validation to ensure all GPU operations complete.

2. **Multiple Render Iterations**: Render multiple frames (typically 10) to ensure consistent results, especially for progressive rendering.

3. **Image Validation**: Use `context->validateImages()` to compare against reference images stored in the test data folder.

4. **Background Color**: Use `TestHelpers::ColorDarkGrey` for consistent background when visualizing AOVs.

## Required Includes

```cpp
#include "composeTaskHelpers.h"

#include <RenderingFramework/TestContextCreator.h>

#include <hvt/engine/framePassUtils.h>
#include <hvt/engine/viewportEngine.h>

#include <gtest/gtest.h>

#include <pxr/pxr.h>

PXR_NAMESPACE_USING_DIRECTIVE
```
